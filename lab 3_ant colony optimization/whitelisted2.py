import time
import copy
import math
import random
import sys

N_ants = 100

# hyperparameter control block
alpha_euc = 0.75
beta_euc = 12.5
rho_euc = 0.25
Q_euc = 1.0

alpha_n = 10.0
beta_n = 20.0
rho_n = 0.25
Q_n = 1.0

class node:
    def __init__(self, x, y):
        self.x = float(x)
        self.y = float(y)
        self.dist = None

def ACO(N, city_matrix, N_ants, phero_matrix, alpha, beta, rho, Q):
    start = time.time()
    # set mincost to negative and assume 1,2,...,N is a min-tour
    mincost = -1
    mintour = []
    for i in range(N):
        mintour.append(i)
    
    runs = 0
    while time.time() < start + 250 or runs > 600 :
        runs += 1
        new_phero_matrix = copy.deepcopy(phero_matrix)
        for ant in range(N_ants):
            tour = []
            tour.append(0)
            while len(tour) != N:
                tour.append(next_city(tour, N, city_matrix, phero_matrix, alpha, beta))
            
            # add up costs of edges formed by consecutive cities in the new tour
            tour_cost = 0
            for i in range(len(tour) - 1):
                tour_cost = tour_cost + city_matrix[tour[i]].dist[tour[i + 1]]

            if mincost == -1:
                mincost = tour_cost
                mintour = tour
            elif mincost > tour_cost: #update best tour if curr tour has less cost
                mincost = tour_cost
                mintour = tour
        
        # get cost generated by an ant
        L_k = 0
        for i in range(len(tour) - 1):
            L_k = L_k + city_matrix[tour[i]].dist[tour[i+1]]
        
        # update pheromone based on evaporation, generation
        for i in range(len(tour) - 1):
            new_phero_matrix[tour[i]][tour[i + 1]] *= rho
            new_phero_matrix[tour[i + 1]][tour[i]] *= rho
            new_phero_matrix[tour[i]][tour[i + 1]] += Q / L_k
            new_phero_matrix[tour[i + 1]][tour[i]] += Q / L_k
        phero_matrix = new_phero_matrix

        # record best tour so far
        best_so_far = 0
        for i in range(len(tour) - 1):
            best_so_far = best_so_far + city_matrix[mintour[i]].dist[mintour[i + 1]]
        print("best",best_so_far)
        print("tour" ,mincost)
        for i in range(N):
            if i == N:
                print(mintour[i])
                break
            print(mintour[i], end = ' ')
        print("\n________________________________________________________________________________________________________\n")
    
    return mintour

def next_city(tour, N, city_matrix, phero_matrix, alpha, beta):
    # array to contain all allowed vertices that kth ant can go to from current position
    allowed_k = []
    for i in range(N):
        if i not in tour:
            allowed_k.append(i)
    
    # calculate the probability of ant moving from i to j
    tau_eta = []
    for i in range(len(allowed_k)):
        tau_alpha = math.pow(phero_matrix[tour[-1]][allowed_k[i]], alpha)
        eta_beta = math.pow((1 / city_matrix[tour[-1]].dist[allowed_k[i]]), beta)
        tau_eta_is = tau_alpha * eta_beta
        tau_eta.append(tau_eta_is)
    
    total_tau_eta = sum(tau_eta)
    p_ij = []
    for i in range(len(allowed_k)):
        p_ij.append(tau_eta[i] / total_tau_eta)
    
    # make the ant move based on that probability
    temp = random.random()
    i = 0
    p = p_ij[i]
    while True:
        if p > temp:
            return allowed_k[i]
        i = i + 1
        p = p + p_ij[i]


# --------------------------------MAIN PROGRAM BEGINS HERE--------------------------------
file = open(str(sys.argv[1]), "r")
# file = open("test-cases/euc_250", "r")

# line 1: type of tsp; euclidean or non-euclidean
tsp_type = str(file.readline().strip())

# line 2: number of cities
N = int(file.readline().strip())

# next N lines: coords of cities
city_matrix = []
for i in range(N):
    x, y = file.readline().strip().split()
    newnode = node(x, y)
    city_matrix.append(newnode)

# get the entire distance matrix
for city in city_matrix:
    city.dist = list(map(float, file.readline().split()))

# initialize pheromone matrix
phero_matrix = []
for i in range(N):
    temp = []
    for j in range(N):
        temp.append(1/N*N*N) ################
    phero_matrix.append(temp)
#print(phero_matrix)

if tsp_type == "euclidean":
    path = ACO(N, city_matrix, N_ants, phero_matrix, alpha_euc, beta_euc, rho_euc, Q_euc)
elif tsp_type == "noneuclidean":
    path = ACO(N, city_matrix, N_ants, phero_matrix, alpha_n, beta_n, rho_n, Q_n)
else:
    print("Invalid file format")